//@version=6

indicator("PTG Smart Alert–Anti-SpamEntryDetection",overlay=true,max_bars_back=200)

// ===== SMART ALERT SYSTEM - ANTI SPAM =====
pairSelection = input.string("XAU/USD", "Trading Pair", options=["EUR/USD", "XAU/USD"])
isPairEURUSD = pairSelection == "EUR/USD"
isPairXAUUSD = pairSelection == "XAU/USD"

pipSize = isPairEURUSD ? 0.0001 : 0.01
useEMA = input.bool(false, "Lọc trend EMA34/55")
useVWAP = input.bool(false, "Lọc trend VWAP")
lookback = input.int(20, "So sánh trong N nến", minval=10)

// H1 optimized parameters
pushRangePct = input.float(0.60, "Range ≥ 60% range lớn nhất N nến", step=0.05)
closePct = input.float(0.60, "Close nằm ở 60–100% cực trị", step=0.05)
oppWickPct = input.float(0.40, "Bóng ngược ≤ 40% range", step=0.05)
volHighMult = input.float(1.2, "Vol ≥ 1.2× SMA Vol", step=0.1)

testBars = input.int(5, "Cho phép TEST trong 1–5 nến", minval=1, maxval=10)
pullbackMax = input.float(0.50, "Pullback ≤ 50% range PUSH", step=0.02)
volLowMult = input.float(1.0, "Vol TEST ≤ 1.0× SMA Vol", step=0.05)

entryBufPip = input.float(0.01, "Đệm Entry (pip)", step=0.01)
slBufPip = input.float(0.01, "Đệm SL (pip)", step=0.01)
tpMultiplier = input.float(2.0, "TP multiplier", step=0.5, minval=1.0, maxval=5.0)

// ===== SMART ALERT SETTINGS =====
alertMode = input.string("Entry Only", "Alert Mode", options=["Entry Only", "Push + Entry", "All Signals"])
minTimeBetweenAlerts = input.int(5, "Min minutes between alerts", minval=1, maxval=60)
onlyHighQuality = input.bool(true, "Only high quality setups")

// Quality filters
minRangeMultiplier = input.float(1.5, "Min range multiplier for quality", step=0.1, minval=1.0)
maxSpreadPip = input.float(0.8, "Max spread for alerts (pip)", step=0.1)

// ===== CORE LOGIC =====
ema34 = ta.ema(close, 34)
ema55 = ta.ema(close, 55)
vwap = ta.vwap

upOK = (not useEMA or ema34 > ema55) and (not useVWAP or close > vwap)
dnOK = (not useEMA or ema34 < ema55) and (not useVWAP or close < vwap)

rng = high - low
rngHi = ta.highest(rng, lookback)
volMA = ta.sma(volume, lookback)
rngMA = ta.sma(rng, lookback)

closePosHi = (close - low) / math.max(rng, 1e-6)
closePosLo = (high - close) / math.max(rng, 1e-6)
lowWick = (math.min(open, close) - low) / math.max(rng, 1e-6)
upWick = (high - math.max(open, close)) / math.max(rng, 1e-6)

bigRange = rng >= rngHi * pushRangePct
hiVol = volume >= volMA * volHighMult and volume > volume[1]

// Quality check
currentSpread = isPairEURUSD ? (high - low) * 10000 : (high - low)
spreadOK = currentSpread <= maxSpreadPip
qualityRange = rng >= rngMA * minRangeMultiplier

// Push detection
pushUp = upOK and bigRange and hiVol and closePosHi >= closePct and upWick <= oppWickPct
pushDn = dnOK and bigRange and hiVol and closePosLo >= closePct and lowWick <= oppWickPct

// High quality filter
highQualityPushUp = pushUp and (not onlyHighQuality or (spreadOK and qualityRange))
highQualityPushDn = pushDn and (not onlyHighQuality or (spreadOK and qualityRange))

plotshape(highQualityPushUp, title="HQ Push Up", style=shape.triangleup, location=location.belowbar,
     color=color.new(color.yellow, 0), size=size.normal, text="PUSH↑", textcolor=color.black)
plotshape(highQualityPushDn, title="HQ Push Down", style=shape.triangledown, location=location.abovebar,
     color=color.new(color.orange, 0), size=size.normal, text="PUSH↓", textcolor=color.white)

var bool waitTest = false
var bool longDir = false
var int iPush = na
var float hiPush = na
var float loPush = na
var float rngPush = na

if (highQualityPushUp or highQualityPushDn)
    waitTest := true
    longDir := highQualityPushUp
    iPush := bar_index
    hiPush := high
    loPush := low
    rngPush := rng

win = waitTest and (bar_index - iPush) >= 1 and (bar_index - iPush) <= testBars

pullOKLong = win and longDir and (hiPush - low) <= pullbackMax * rngPush
pullOKShort = win and (not longDir) and (high - loPush) <= pullbackMax * rngPush
lowVol = volume <= volMA * volLowMult
smallRng = rng <= rngMA * 1.2

testLong = pullOKLong and lowVol and smallRng
testShort = pullOKShort and lowVol and smallRng

plotshape(testLong, title="Test Long", style=shape.circle, location=location.belowbar,
     color=color.new(color.lime, 0), size=size.normal, text="TEST", textcolor=color.black)
plotshape(testShort, title="Test Short", style=shape.circle, location=location.abovebar,
     color=color.new(color.red, 0), size=size.normal, text="TEST", textcolor=color.white)

var float testHi = na
var float testLo = na
if testLong
    testHi := high
    testLo := low
if testShort
    testHi := high
    testLo := low

useHi = na(testHi) ? hiPush : testHi
useLo = na(testLo) ? loPush : testLo

buf = entryBufPip * pipSize
slBuf = slBufPip * pipSize

longEntry = useHi + buf
shortEntry = useLo - buf

// ENTRY SIGNALS
goLong = testLong
goShort = testShort

slLong = (na(testLo) ? loPush : testLo) - slBuf
slShort = (na(testHi) ? hiPush : testHi) + slBuf

tp1L = longEntry + pipSize * tpMultiplier
tp1S = shortEntry - pipSize * tpMultiplier

// ===== SMART ALERT SYSTEM =====
// Track last alert time to prevent spam
var int lastAlertTime = 0
var string lastAlertType = ""

// Convert minutes to bars (approximate)
minBarsGap = math.max(1, minTimeBetweenAlerts)
canAlert = (bar_index - lastAlertTime) >= minBarsGap

// Alert conditions with anti-spam
pushAlertLong = alertMode != "Entry Only" and highQualityPushUp and canAlert
pushAlertShort = alertMode != "Entry Only" and highQualityPushDn and canAlert

entryAlertLong = goLong and canAlert and (not onlyHighQuality or spreadOK)
entryAlertShort = goShort and canAlert and (not onlyHighQuality or spreadOK)

// Update last alert time
if (pushAlertLong or pushAlertShort or entryAlertLong or entryAlertShort)
    lastAlertTime := bar_index

// ===== VISUAL ENTRY SIGNALS =====
plotshape(goLong, title="GO Long", style=shape.labelup, location=location.belowbar,
     color=color.new(color.lime, 0), text="ENTRY", textcolor=color.black, size=size.large)
plotshape(goShort, title="GO Short", style=shape.labeldown, location=location.abovebar,
     color=color.new(color.red, 0), text="ENTRY", textcolor=color.white, size=size.large)

plot(goLong ? slLong : na, title="SL Long", style=plot.style_linebr, color=color.red, linewidth=3)
plot(goShort ? slShort : na, title="SL Short", style=plot.style_linebr, color=color.red, linewidth=3)
plot(goLong ? tp1L : na, title="TP Long", style=plot.style_linebr, color=color.green, linewidth=3)
plot(goShort ? tp1S : na, title="TP Short", style=plot.style_linebr, color=color.green, linewidth=3)

// ===== CONSOLIDATED ALERT SYSTEM =====
// Single comprehensive alert for each direction
longSignalStrength = (highQualityPushUp ? 1 : 0) + (testLong ? 2 : 0) + (goLong ? 4 : 0)
shortSignalStrength = (highQualityPushDn ? 1 : 0) + (testShort ? 2 : 0) + (goShort ? 4 : 0)

// Main alerts - only fire on entry with all info
alertcondition(entryAlertLong, title="🚀 PTG LONG ENTRY", 
    message="🚀 PTG LONG ENTRY\n" + 
            "Pair: " + pairSelection + "\n" +
            "Entry: " + str.tostring(longEntry, "#.

###") + "\n" +

"SL: " +str.tostring(slLong,"#.###")+"\n"+
"TP: " + str.tostring(tp1L, "#.###") + "\n" +

"Risk: " + str.tostring(math.abs(longEntry - slLong) / pipSize, "#.#") + " pips")

alertcondition(entryAlertShort, title="🔻 PTG SHORT ENTRY", 
    message="🔻 PTG SHORT ENTRY\n" + 
            "Pair: " + pairSelection + "\n" +
            "Entry: " + str.tostring(shortEntry, "#.

###") + "\n" +

"SL: " +str.tostring(slShort,"#.###")+"\n"+
"TP: " + str.tostring(tp1S, "#.###") + "\n" +

"Risk: " + str.tostring(math.abs(shortEntry - slShort) / pipSize, "#.#") + " pips")

// Optional: Early warning alerts (if enabled)
alertcondition(pushAlertLong and alertMode == "Push + Entry", title="⚠️ PTG PUSH UP", 
    message="⚠️ PUSH UP detected on " + pairSelection + " - Watch for TEST phase")

alertcondition(pushAlertShort and alertMode == "Push + Entry", title="⚠️ PTG PUSH DOWN", 
    message="⚠️ PUSH DOWN detected on " + pairSelection + " - Watch for TEST phase")

// ===== STATUS TABLE =====
var table statusTable = table.new(position.top_right, 2, 8, bgcolor=color.white, border_width=1)
if barstate.islast
    table.cell(statusTable, 0, 0, "PTG SMART", text_color=color.white, bgcolor=color.blue, text_size=size.normal)
    table.cell(statusTable, 1, 0, "ALERT", text_color=color.white, bgcolor=color.blue, text_size=size.normal)
    
    table.cell(statusTable, 0, 1, "Mode", text_color=color.black, text_size=size.small)
    table.cell(statusTable, 1, 1, alertMode == "Entry Only" ? "ENTRY" : alertMode == "Push + Entry" ? "PUSH+E" : "ALL", 
               text_color=color.blue, text_size=size.small)
    
    table.cell(statusTable, 0, 2, "Min Gap", text_color=color.black, text_size=size.tiny)
    table.cell(statusTable, 1, 2, str.tostring(minTimeBetweenAlerts) + "m", text_color=color.orange, text_size=size.tiny)
    
    table.cell(statusTable, 0, 3, "Quality", text_color=color.black, text_size=size.tiny)
    table.cell(statusTable, 1, 3, onlyHighQuality ? "HIGH" : "ALL", text_color=onlyHighQuality ? color.green : color.gray, text_size=size.tiny)
    
    table.cell(statusTable, 0, 4, "Spread", text_color=color.black, text_size=size.tiny)
    table.cell(statusTable, 1, 4, str.tostring(currentSpread, "#.#"), 
               text_color=spreadOK ? color.green : color.red, text_size=size.tiny)
    
    table.cell(statusTable, 0, 5, "Last Alert", text_color=color.black, text_size=size.tiny)
    barsAgo = bar_index - lastAlertTime
    table.cell(statusTable, 1, 5, barsAgo > 100 ? "None" : str.tostring(barsAgo) + "b", 
               text_color=color.purple, text_size=size.tiny)
    
    table.cell(statusTable, 0, 6, "Can Alert", text_color=color.black, text_size=size.tiny)
    table.cell(statusTable, 1, 6, canAlert ? "YES" : "NO", 
               text_color=canAlert ? color.green : color.red, text_size=size.tiny)
    
    table.cell(statusTable, 0, 7, "Pair", text_color=color.black, text_size=size.tiny)
    table.cell(statusTable, 1, 7, pairSelection, text_color=color.blue, text_size=size.tiny)

// Reset waitTest
if (goLong or goShort) or (win and (bar_index - iPush) == testBars)
    waitTest := false
    testHi := na
    testLo := na

// Hidden plots for alert data
plot(goLong ? longEntry : goShort ? shortEntry : na, title="Entry Price", display=display.none)
plot(goLong ? slLong : goShort ? slShort : na, title="SL Price", display=display.none)
plot(goLong ? tp1L : goShort ? tp1S : na, title="TP Price", display=display.none)