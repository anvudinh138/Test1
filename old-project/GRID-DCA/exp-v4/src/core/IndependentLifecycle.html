//+------------------------------------------------------------------+
//|                                      IndependentLifecycle.mqh  |
//|                                       FlexGridDCA EA v3.0.0      |
//|                                Self-Managing Lifecycle Core     |
//+------------------------------------------------------------------+
#property copyright "FlexGridDCA EA v3.0"
#property version   "1.00"

#include <Trade\Trade.mqh>
#include <GridManager_v2.mqh>
#include <ATRCalculator.mqh>

//+------------------------------------------------------------------+
//| Lifecycle States                                               |
//+------------------------------------------------------------------+
enum LIFECYCLE_STATE
{
    LIFECYCLE_INITIALIZING,    // Setting up grid
    LIFECYCLE_ACTIVE,          // Normal grid trading
    LIFECYCLE_DCA_RESCUE,      // DCA rescue mode
    LIFECYCLE_TRAILING,        // Trailing stop active
    LIFECYCLE_CLOSING,         // Closing all positions
    LIFECYCLE_COMPLETED,       // Lifecycle finished
    LIFECYCLE_EMERGENCY        // Emergency shutdown
};

//+------------------------------------------------------------------+
//| Independent Self-Managing Lifecycle                            |
//+------------------------------------------------------------------+
class CIndependentLifecycle
{
private:
    // Core identification
    int                 m_id;
    string              m_symbol;
    datetime            m_start_time;
    LIFECYCLE_STATE     m_state;
    
    // Grid management
    CGridManagerV2*     m_grid_manager;
    CATRCalculator*     m_atr_calculator;
    CTrade              m_trade;
    
    // Financial tracking
    double              m_allocated_balance;
    double              m_profit_target;
    double              m_stop_loss;
    double              m_current_profit;
    double              m_peak_profit;
    double              m_max_loss;
    
    // Grid settings
    int                 m_grid_levels;
    double              m_lot_size;
    double              m_atr_multiplier;
    
    // Risk management
    double              m_current_risk;
    double              m_max_risk_allowed;
    bool                m_emergency_shutdown_requested;
    string              m_emergency_reason;
    
    // Trailing stop
    bool                m_trailing_active;
    double              m_trailing_threshold;
    double              m_trailing_atr_multiplier;  // NEW: Configurable ATR multiplier
    bool                m_enable_trailing_stop;     // NEW: Enable/disable trailing stop
    bool                m_partial_profit_taken;
    
    // DCA management
    bool                m_dca_activated;
    int                 m_dca_expansions;
    bool                m_dca_orders_placed;     // NEW: Track if DCA orders placed
    double              m_dca_lot_size;          // NEW: Configurable DCA lot size
    
    // Lifecycle management
    bool                m_is_active;
    bool                m_is_completed;
    datetime            m_last_update;
    datetime            m_last_risk_check;
    
    // Order cleanup tracking
    bool                m_orders_cleaned;

    // v4: Hedge options and controls
    bool                m_disable_dca;          // If true: never enter DCA rescue
    bool                m_enable_oco;           // If true: OCO cancel opposite after first fill
    bool                m_oco_triggered;
    datetime            m_oco_rearm_time;
    int                 m_oco_cooldown_seconds;
    
    // v4: Trend filters
    bool                m_enable_adx_filter;
    int                 m_adx_period;
    double              m_adx_threshold;
    double              m_min_atr_points;
    int                 m_adx_handle;
    
    // v4: OCO gating
    int                 m_oco_arm_distance_points;
    double              m_oco_profit_confirm_usd;
    
public:
    //+------------------------------------------------------------------+
    //| Constructor                                                      |
    //+------------------------------------------------------------------+
    CIndependentLifecycle(int id, string symbol, double profit_target, double stop_loss, 
                         int grid_levels, double lot_size, double allocated_balance, 
                         double trailing_atr_multiplier = 2.0, double dca_lot_size = 0.02, 
                         bool enable_trailing_stop = false,
                         bool disable_dca = true,
                         bool enable_oco = true,
                         int oco_cooldown_seconds = 180,
                         bool enable_adx_filter = true,
                         int adx_period = 14,
                         double adx_threshold = 18.0,
                         double min_atr_points = 100.0,
                         int oco_arm_distance_points = 200,
                         double oco_profit_confirm_usd = 0.0)
    {
        m_id = id;
        m_symbol = symbol;
        m_profit_target = profit_target;
        m_stop_loss = stop_loss;
        m_grid_levels = grid_levels;
        m_lot_size = lot_size;
        m_allocated_balance = allocated_balance;
        
        m_start_time = TimeCurrent();
        m_state = LIFECYCLE_INITIALIZING;
        
        // Initialize financial tracking
        m_current_profit = 0.0;
        m_peak_profit = 0.0;
        m_max_loss = 0.0;
        m_current_risk = 0.0;
        m_max_risk_allowed = stop_loss; // Risk cannot exceed stop loss
        
        // Initialize flags
        m_is_active = true;
        m_is_completed = false;
        m_emergency_shutdown_requested = false;
        m_trailing_active = false;
        m_trailing_atr_multiplier = trailing_atr_multiplier;  // NEW: Set configurable ATR multiplier
        m_enable_trailing_stop = enable_trailing_stop;       // NEW: Set trailing stop enable
        m_partial_profit_taken = false;
        m_dca_activated = false;
        m_dca_expansions = 0;
        m_dca_orders_placed = false;     // NEW: Initialize DCA flag
        m_dca_lot_size = dca_lot_size;   // NEW: Set DCA lot size
        m_orders_cleaned = false;
        
        // v4: Hedge options
        m_disable_dca = disable_dca;
        m_enable_oco = enable_oco;
        m_oco_triggered = false;
        m_oco_cooldown_seconds = oco_cooldown_seconds;
        m_oco_rearm_time = 0;
        
        // v4: Trend filter setup
        m_enable_adx_filter = enable_adx_filter;
        m_adx_period = adx_period;
        m_adx_threshold = adx_threshold;
        m_min_atr_points = min_atr_points;
        m_adx_handle = INVALID_HANDLE;
        m_oco_arm_distance_points = oco_arm_distance_points;
        m_oco_profit_confirm_usd = oco_profit_confirm_usd;
        
        m_last_update = TimeCurrent();
        m_last_risk_check = TimeCurrent();
        
        // Initialize grid components
        m_grid_manager = new CGridManagerV2();
        m_atr_calculator = new CATRCalculator();
        
        if(m_grid_manager != NULL && m_atr_calculator != NULL)
        {
            // CRITICAL: Initialize ATR Calculator first
                if(!m_atr_calculator.Initialize(m_symbol))
                {
                    Print("‚ùå LIFECYCLE #", m_id, " Failed to initialize ATR Calculator");
                    RequestEmergencyShutdown("ATR Calculator initialization failed");
                    return;
                }
                
                m_grid_manager.Initialize(m_symbol, m_grid_levels, m_lot_size);
                m_grid_manager.SetATRCalculator(m_atr_calculator);
                m_grid_manager.SetJobID(m_id);          // NEW: Set job ID for order comments
                m_grid_manager.SetDCALotSize(m_dca_lot_size); // NEW: Set DCA lot size
                
                // Grid Manager Job ID set - debug logging removed
            
            Print("‚úÖ LIFECYCLE #", m_id, " ATR Calculator initialized successfully");
        }
        
        // Initialize ADX handle if enabled
        if(m_enable_adx_filter)
        {
            m_adx_handle = iADX(m_symbol, PERIOD_H1, m_adx_period);
            if(m_adx_handle == INVALID_HANDLE)
            {
                Print("‚ö†Ô∏è LIFECYCLE #", m_id, " Failed to create ADX handle; disabling ADX filter");
                m_enable_adx_filter = false;
            }
        }
        
        Print("üöÄ LIFECYCLE #", m_id, " CREATED: Target=$", DoubleToString(m_profit_target, 2), 
              " StopLoss=$", DoubleToString(m_stop_loss, 2), " Levels=", m_grid_levels);
    }
    
    //+------------------------------------------------------------------+
    //| Destructor                                                       |
    //+------------------------------------------------------------------+
    ~CIndependentLifecycle()
    {
        if(m_grid_manager != NULL)
        {
            delete m_grid_manager;
            m_grid_manager = NULL;
        }
        
        if(m_atr_calculator != NULL)
        {
            delete m_atr_calculator;
            m_atr_calculator = NULL;
        }
        
        if(m_adx_handle != INVALID_HANDLE)
        {
            IndicatorRelease(m_adx_handle);
            m_adx_handle = INVALID_HANDLE;
        }
        
        Print("üßπ LIFECYCLE #", m_id, " DESTROYED");
    }
    
    //+------------------------------------------------------------------+
    //| Main Update Function - SELF MANAGEMENT                         |
    //+------------------------------------------------------------------+
    void Update()
    {
        if(!m_is_active || m_is_completed) return;
        
        datetime current_time = TimeCurrent();
        
        // Update financial tracking
        UpdateFinancialStatus();
        
        // Risk check every 30 seconds
        if(current_time - m_last_risk_check > 30)
        {
            if(!PerformSelfRiskCheck())
            {
                return; // Emergency shutdown requested
            }
            m_last_risk_check = current_time;
        }
        
        // State machine
        switch(m_state)
        {
            case LIFECYCLE_INITIALIZING:
                HandleInitializingState();
                break;
                
            case LIFECYCLE_ACTIVE:
                HandleActiveState();
                break;
                
            case LIFECYCLE_DCA_RESCUE:
                // Only reachable if DCA enabled
                HandleDCARescueState();
                break;
                
            case LIFECYCLE_TRAILING:
                HandleTrailingState();
                break;
                
            case LIFECYCLE_CLOSING:
                HandleClosingState();
                break;
                
            case LIFECYCLE_EMERGENCY:
                HandleEmergencyState();
                break;
        }
        
        m_last_update = current_time;
    }
    
    //+------------------------------------------------------------------+
    //| Financial Status Update                                        |
    //+------------------------------------------------------------------+
    void UpdateFinancialStatus()
    {
        if(m_grid_manager == NULL) return;
        
        m_current_profit = CalculateTotalProfit();
        
        // Update peak profit
        if(m_current_profit > m_peak_profit)
        {
            m_peak_profit = m_current_profit;
        }
        
        // Update max loss
        if(m_current_profit < m_max_loss)
        {
            m_max_loss = m_current_profit;
        }
        
        // Calculate current risk (unrealized loss)
        m_current_risk = MathAbs(MathMin(0.0, m_current_profit));
    }
    
    //+------------------------------------------------------------------+
    //| Self Risk Management - CRITICAL                                |
    //+------------------------------------------------------------------+
    bool PerformSelfRiskCheck()
    {
        // Check stop loss
        if(m_current_profit <= -m_stop_loss)
        {
            RequestEmergencyShutdown(StringFormat("Stop Loss Hit: $%.2f <= -$%.2f", 
                                                 m_current_profit, m_stop_loss));
            return false;
        }
        
        // Check maximum risk
        if(m_current_risk > m_max_risk_allowed)
        {
            RequestEmergencyShutdown(StringFormat("Max Risk Exceeded: $%.2f > $%.2f", 
                                                 m_current_risk, m_max_risk_allowed));
            return false;
        }
        
        // Check for runaway positions (too many positions)
        int total_positions = GetLifecyclePositionCount();
        if(total_positions > m_grid_levels * 4) // 4x normal grid size
        {
            RequestEmergencyShutdown(StringFormat("Too Many Positions: %d > %d", 
                                                 total_positions, m_grid_levels * 4));
            return false;
        }
        
        return true;
    }
    
    //+------------------------------------------------------------------+
    //| State Handlers                                                 |
    //+------------------------------------------------------------------+
    void HandleInitializingState()
    {
        if(m_grid_manager == NULL) return;
        
        // Setup initial grid with ATR multiplier
        double current_price = SymbolInfoDouble(m_symbol, SYMBOL_BID);
        if(m_grid_manager.SetupDualGrid(current_price, 1.2)) // Use default ATR multiplier
        {
            m_state = LIFECYCLE_ACTIVE;
            Print("üìä LIFECYCLE #", m_id, " GRID SETUP COMPLETE - Now ACTIVE");
        }
        else
        {
            RequestEmergencyShutdown("Failed to setup initial grid");
        }
    }
    
    void HandleActiveState()
    {
        if(m_grid_manager == NULL) return;
        
        // Update grid status
        m_grid_manager.UpdateGridStatus();

        // v4: OCO enforcement
        if(m_enable_oco)
        {
            EnforceOCOLogic();
        }
        
        // Check for DCA trigger (disabled in momentum mode)
        if(!m_disable_dca && !m_dca_activated && m_grid_manager.CheckSmartDCAExpansion())
        {
            m_dca_activated = true;
            m_state = LIFECYCLE_DCA_RESCUE;
            Print("üö® LIFECYCLE #", m_id, " DCA RESCUE ACTIVATED");
            return;
        }
        
        // Check for profit target (trailing activation) - ONLY IF ENABLED
        // DEBUG: Log profit status in ACTIVE state
        static datetime last_active_profit_debug = 0;
        if(TimeCurrent() - last_active_profit_debug > 60) // Every minute in ACTIVE state
        {
            Print("üí∞ LIFECYCLE #", m_id, " ACTIVE PROFIT: Current=$", DoubleToString(m_current_profit, 2), 
                  " Target=$", DoubleToString(m_profit_target, 2));
            last_active_profit_debug = TimeCurrent();
        }
        
        if(m_current_profit >= m_profit_target)
        {
            if(m_enable_trailing_stop)
            {
                Print("üéØ LIFECYCLE #", m_id, " PROFIT TARGET REACHED - ACTIVATING TRAILING: $", DoubleToString(m_current_profit, 2));
                ActivateTrailingStop();
                return;
            }
            else
            {
                // Trailing disabled ‚Üí Close at profit target
                m_state = LIFECYCLE_CLOSING;
                Print("üéØ LIFECYCLE #", m_id, " PROFIT TARGET REACHED: $", DoubleToString(m_current_profit, 2), " (Trailing DISABLED)");
                return;
            }
        }
        
        // Trend filter: only place orders if trend is strong enough
        if(IsTrendArmed())
        {
            m_grid_manager.PlaceGridOrders();
        }
    }
    
    void HandleDCARescueState()
    {
        if(m_grid_manager == NULL) return;
        
        // Update grid status and calculate profit
        m_grid_manager.UpdateGridStatus();
        m_current_profit = CalculateTotalProfit();

        // v4: OCO enforcement also in DCA state
        if(m_enable_oco)
        {
            EnforceOCOLogic();
        }
        
        // MINIMAL LOGGING: Only log DCA progress every 5 minutes
        static datetime last_dca_log = 0;
        if(TimeCurrent() - last_dca_log > 300) // 5 minutes
        {
            Print("üìà LIFECYCLE #", m_id, " DCA RECOVERY: $", DoubleToString(m_current_profit, 2));
            last_dca_log = TimeCurrent();
        }
        
        // üö® INITIAL DCA PLACEMENT: Only place DCA orders once when entering rescue mode
        if(!m_dca_orders_placed)
        {
            PlaceDCAOrders();
            m_dca_orders_placed = true;
        }
        
        // Continue normal operations with DCA active if trend OK
        if(IsTrendArmed())
            m_grid_manager.PlaceGridOrders();
        
        // üéØ CHECK PROFIT TARGET - CRITICAL FOR CLOSING LIFECYCLE
        // DEBUG: Log profit comparison every 30 seconds
        static datetime last_profit_debug = 0;
        if(TimeCurrent() - last_profit_debug > 30)
        {
            Print("üí∞ LIFECYCLE #", m_id, " PROFIT CHECK: Current=$", DoubleToString(m_current_profit, 2), 
                  " Target=$", DoubleToString(m_profit_target, 2), 
                  " Trailing=", (m_enable_trailing_stop ? "ON" : "OFF"));
            last_profit_debug = TimeCurrent();
        }
        
        if(m_current_profit >= m_profit_target)
        {
            if(m_enable_trailing_stop)
            {
                Print("üéØ LIFECYCLE #", m_id, " PROFIT TARGET REACHED - ACTIVATING TRAILING: $", DoubleToString(m_current_profit, 2));
                ActivateTrailingStop();
                return;
            }
            else
            {
                // Trailing disabled ‚Üí Close immediately at profit target
                m_state = LIFECYCLE_CLOSING;
                Print("üéØ LIFECYCLE #", m_id, " PROFIT TARGET REACHED - CLOSING: $", DoubleToString(m_current_profit, 2), " (Trailing DISABLED)");
                return;
            }
        }
        
        // üö® CHECK EMERGENCY STOP LOSS (expanded in DCA mode)
        double emergency_stop = m_stop_loss * 1.5; // 1.5x stop loss in DCA mode
        if(m_current_profit <= -emergency_stop)
        {
            Print("üö® LIFECYCLE #", m_id, " EMERGENCY STOP LOSS HIT: $", DoubleToString(m_current_profit, 2));
            RequestEmergencyShutdown("Emergency stop loss in DCA mode");
            return;
        }
    }
    
    void HandleTrailingState()
    {
        // üßπ CRITICAL: Clean all pending orders to avoid conflicts
        if(!m_orders_cleaned)
        {
            CleanAllPendingOrders();
            m_orders_cleaned = true;
            Print("üßπ LIFECYCLE #", m_id, " CLEANED ALL PENDING ORDERS - Trailing Mode");
        }
        
        // üéØ FIXED TRAILING LOGIC: ATR-based trailing stop like STABLE-V1
        // Use configurable ATR multiplier from constructor
        double current_atr = 0.001; // Fallback
        
        // Get ATR from grid manager
        if(m_grid_manager != NULL)
        {
            current_atr = m_grid_manager.CalculateGridSpacing() / 1.2; // Reverse calculate ATR
            if(current_atr < 0.0005) current_atr = 0.001; // Minimum ATR
        }
        
        // Calculate ATR-based trailing distance
        double atr_trailing_distance = current_atr * m_trailing_atr_multiplier; // Configurable ATR distance
        double atr_trailing_distance_usd = atr_trailing_distance * 100000.0; // Convert to USD (rough estimate)
        
        // üö® ENHANCED TRAILING LOGIC: Combination of percentage + ATR
        // Update trailing threshold (can move up OR down based on market)
        double percentage_threshold = m_current_profit * 0.7; // 70% of current profit
        double atr_threshold = m_peak_profit - atr_trailing_distance_usd; // ATR-based from peak
        
        // Use the more conservative (higher) threshold
        double new_trailing_threshold = MathMax(percentage_threshold, atr_threshold);
        
        // Always update threshold (can go up or down) - SILENT UPDATES
        m_trailing_threshold = new_trailing_threshold;
        
        // üõë TRAILING STOP CHECK: Close if profit drops below threshold
        if(m_current_profit <= m_trailing_threshold)
        {
            m_state = LIFECYCLE_CLOSING;
            Print("üèÉ LIFECYCLE #", m_id, " TRAILING STOP TRIGGERED: Profit $", DoubleToString(m_current_profit, 2), 
                  " <= Threshold $", DoubleToString(m_trailing_threshold, 2));
        }
        
        // üö® EMERGENCY STOP: If profit drops too much from peak (like breakeven protection)
        double max_drawdown_from_peak = m_peak_profit * 0.5; // 50% drawdown from peak
        if(m_current_profit <= max_drawdown_from_peak && m_peak_profit > m_profit_target)
        {
            m_state = LIFECYCLE_CLOSING;
            Print("üö® LIFECYCLE #", m_id, " EMERGENCY TRAILING STOP: Profit dropped 50% from peak $", 
                  DoubleToString(m_peak_profit, 2), " to $", DoubleToString(m_current_profit, 2));
        }
    }
    
    void HandleClosingState()
    {
        // DEBUG: Log closing attempts
        static datetime last_closing_log = 0;
        if(TimeCurrent() - last_closing_log > 5) // Every 5 seconds
        {
            int remaining_positions = GetLifecyclePositionCount();
            int remaining_orders = GetLifecyclePendingOrderCount();
            Print("üîÑ LIFECYCLE #", m_id, " CLOSING: ", remaining_positions, " positions + ", remaining_orders, " orders remaining");
            last_closing_log = TimeCurrent();
        }
        
        // üßπ CRITICAL: Clean all pending orders first to avoid conflicts
        CleanAllPendingOrders();
        
        // üí∞ Close all positions for this lifecycle
        CloseAllLifecyclePositions();
        
        // Check if all closed
        int remaining_positions = GetLifecyclePositionCount();
        int remaining_orders = GetLifecyclePendingOrderCount();
        
        if(remaining_positions == 0 && remaining_orders == 0)
        {
            m_state = LIFECYCLE_COMPLETED;
            m_is_completed = true;
            m_is_active = false;
            Print("‚úÖ LIFECYCLE #", m_id, " COMPLETED: Final profit $", DoubleToString(m_current_profit, 2));
        }
        else
        {
            Print("‚è≥ LIFECYCLE #", m_id, " STILL CLOSING: ", remaining_positions, " positions + ", remaining_orders, " orders remaining");
        }
    }
    
    void HandleEmergencyState()
    {
        // Emergency close everything
        CloseAllLifecyclePositions();
        CleanAllPendingOrders();
        
        m_state = LIFECYCLE_COMPLETED;
        m_is_completed = true;
        m_is_active = false;
        
        Print("üö® LIFECYCLE #", m_id, " EMERGENCY SHUTDOWN COMPLETE");
    }
    
    //+------------------------------------------------------------------+
    //| Trailing Stop Activation                                       |
    //+------------------------------------------------------------------+
    void ActivateTrailingStop()
    {
        m_trailing_active = true;
        m_trailing_threshold = m_current_profit * 0.7; // Start at 70% of current profit
        m_state = LIFECYCLE_TRAILING;
        
        Print("üéØ LIFECYCLE #", m_id, " PROFIT TARGET REACHED: $", DoubleToString(m_current_profit, 2));
        Print("üèÉ LIFECYCLE #", m_id, " TRAILING STOP ACTIVATED: Threshold $", DoubleToString(m_trailing_threshold, 2));
    }

    //+------------------------------------------------------------------+
    //| v4: OCO and Trend Filter Helpers                               |
    //+------------------------------------------------------------------+
    bool IsTrendArmed()
    {
        if(!m_enable_adx_filter)
            return true;
        
        // Check ADX main value
        double adx_buf[];
        ArraySetAsSeries(adx_buf, true);
        if(m_adx_handle == INVALID_HANDLE)
            return true; // fail-open
        if(CopyBuffer(m_adx_handle, 0, 0, 1, adx_buf) <= 0)
            return true; // fail-open
        double adx = adx_buf[0];
        
        // Check ATR threshold in points
        double atr_h1 = m_atr_calculator != NULL ? m_atr_calculator.GetATR(PERIOD_H1) : 0.0;
        double atr_points = atr_h1 / _Point;
        
        if(adx >= m_adx_threshold && atr_points >= m_min_atr_points)
            return true;
        
        return false;
    }
    
    int DetectOpenDirection()
    {
        string job_prefix = StringFormat("J%d_", m_id);
        for(int i = 0; i < PositionsTotal(); i++)
        {
            ulong ticket = PositionGetTicket(i);
            if(PositionSelectByTicket(ticket))
            {
                if(PositionGetString(POSITION_SYMBOL) != m_symbol)
                    continue;
                string comment = PositionGetString(POSITION_COMMENT);
                if(StringFind(comment, job_prefix) >= 0)
                {
                    ENUM_POSITION_TYPE t = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
                    if(t == POSITION_TYPE_BUY) return GRID_DIRECTION_BUY;
                    if(t == POSITION_TYPE_SELL) return GRID_DIRECTION_SELL;
                }
            }
        }
        return -1;
    }
    
    void EnforceOCOLogic()
    {
        int open_dir = DetectOpenDirection();
        if(open_dir == -1)
        {
            // No open positions for this job
            if(m_oco_triggered && TimeCurrent() >= m_oco_rearm_time)
            {
                // Reactivate both directions after cooldown
                m_grid_manager.SetDirectionActive(GRID_DIRECTION_BUY, true);
                m_grid_manager.SetDirectionActive(GRID_DIRECTION_SELL, true);
                m_oco_triggered = false;
                Print("üîÅ LIFECYCLE #", m_id, " OCO re-armed: both directions active");
            }
            return;
        }
        
        // There is an open direction; check OCO gating before canceling
        GRID_DIRECTION opposite = (open_dir == GRID_DIRECTION_BUY) ? GRID_DIRECTION_SELL : GRID_DIRECTION_BUY;
        if(!m_oco_triggered)
        {
            if(ShouldTriggerOCO(open_dir))
            {
                m_grid_manager.SetDirectionActive(opposite, false);
                m_grid_manager.CancelPendingOrders(opposite);
                m_oco_triggered = true;
                m_oco_rearm_time = TimeCurrent() + m_oco_cooldown_seconds;
                Print("ü™ô LIFECYCLE #", m_id, " OCO triggered: deactivated ", (opposite==GRID_DIRECTION_BUY?"BUY":"SELL"), " side");
            }
        }
    }

    bool ShouldTriggerOCO(int open_dir)
    {
        // Profit confirmation (optional)
        if(m_oco_profit_confirm_usd > 0.0 && m_current_profit < m_oco_profit_confirm_usd)
            return false;
        
        // Arm distance from base price (optional)
        if(m_oco_arm_distance_points <= 0)
            return true; // no gating
        
        double base = m_grid_manager.GetBasePrice();
        double price = (open_dir == GRID_DIRECTION_BUY) ? SymbolInfoDouble(m_symbol, SYMBOL_BID)
                                                       : SymbolInfoDouble(m_symbol, SYMBOL_ASK);
        double delta_points = (price - base) / _Point;
        
        if(open_dir == GRID_DIRECTION_BUY)
        {
            return delta_points >= m_oco_arm_distance_points;
        }
        else
        {
            return (-delta_points) >= m_oco_arm_distance_points; // price below base by threshold
        }
    }
    
    //+------------------------------------------------------------------+
    //| Order and Position Management                                  |
    //+------------------------------------------------------------------+
    void CleanAllPendingOrders()
    {
        string job_prefix = StringFormat("J%d_", m_id); // Match this job's orders
        
        for(int i = OrdersTotal() - 1; i >= 0; i--)
        {
            ulong ticket = OrderGetTicket(i);
            if(OrderSelect(ticket))
            {
                string comment = OrderGetString(ORDER_COMMENT);
                if(StringFind(comment, job_prefix) >= 0) // This job's orders (J1_, J2_, etc.)
                {
                    if(m_trade.OrderDelete(ticket))
                    {
                        Print("üóëÔ∏è LIFECYCLE #", m_id, " Cancelled order #", ticket, " (", comment, ")");
                    }
                }
            }
        }
    }
    
    void CloseAllLifecyclePositions()
    {
        string job_prefix = StringFormat("J%d_", m_id); // Match this job's positions
        int closed_count = 0;
        
        for(int i = PositionsTotal() - 1; i >= 0; i--)
        {
            ulong ticket = PositionGetTicket(i);
            if(PositionSelectByTicket(ticket))
            {
                string comment = PositionGetString(POSITION_COMMENT);
                if(StringFind(comment, job_prefix) >= 0) // This job's positions (J1_, J2_, etc.)
                {
                    if(m_trade.PositionClose(ticket))
                    {
                        closed_count++;
                        Print("üí∞ LIFECYCLE #", m_id, " Closed position #", ticket, " (", comment, ")");
                    }
                    else
                    {
                        Print("‚ùå LIFECYCLE #", m_id, " FAILED to close position #", ticket, " (", comment, ")");
                    }
                }
            }
        }
        
        Print("üßπ LIFECYCLE #", m_id, " CLOSING SUMMARY: ", closed_count, " positions closed");
    }
    
    int GetLifecyclePositionCount()
    {
        string job_prefix = StringFormat("J%d_", m_id); // Match this job's positions
        int count = 0;
        
        for(int i = 0; i < PositionsTotal(); i++)
        {
            ulong ticket = PositionGetTicket(i);
            if(PositionSelectByTicket(ticket))
            {
                string comment = PositionGetString(POSITION_COMMENT);
                if(StringFind(comment, job_prefix) >= 0) // This job's positions (J1_, J2_, etc.)
                {
                    count++;
                }
            }
        }
        return count;
    }
    
    int GetLifecyclePendingOrderCount()
    {
        string job_prefix = StringFormat("J%d_", m_id); // Match this job's orders
        int count = 0;
        
        for(int i = 0; i < OrdersTotal(); i++)
        {
            ulong ticket = OrderGetTicket(i);
            if(OrderSelect(ticket))
            {
                string comment = OrderGetString(ORDER_COMMENT);
                if(StringFind(comment, job_prefix) >= 0) // This job's orders (J1_, J2_, etc.)
                {
                    count++;
                }
            }
        }
        return count;
    }
    
    //+------------------------------------------------------------------+
    //| Emergency Management                                           |
    //+------------------------------------------------------------------+
    void RequestEmergencyShutdown(string reason)
    {
        m_emergency_shutdown_requested = true;
        m_emergency_reason = reason;
        m_state = LIFECYCLE_EMERGENCY;
        
        Print("üö® LIFECYCLE #", m_id, " REQUESTS EMERGENCY SHUTDOWN: ", reason);
    }
    
    void EmergencyClose()
    {
        m_state = LIFECYCLE_EMERGENCY;
        HandleEmergencyState();
    }
    
    //+------------------------------------------------------------------+
    //| Public Interface                                               |
    //+------------------------------------------------------------------+
    int GetID() { return m_id; }
    bool IsActive() { return m_is_active; }
    bool IsCompleted() { return m_is_completed; }
    double GetCurrentProfit() { return m_current_profit; }
    double GetCurrentRisk() { return m_current_risk; }
    double GetAllocatedBalance() { return m_allocated_balance; }
    LIFECYCLE_STATE GetState() { return m_state; }
    
    // üö® NEW: Get DCA expansion count for trigger detection
    int GetDCAExpansions() 
    { 
        if(m_grid_manager != NULL)
        {
            // Get total DCA expansions from both directions
            int buy_expansions = m_grid_manager.GetDirectionDCAExpansions(GRID_DIRECTION_BUY);
            int sell_expansions = m_grid_manager.GetDirectionDCAExpansions(GRID_DIRECTION_SELL);
            return MathMax(buy_expansions, sell_expansions); // Return highest expansion count
        }
        return 0; 
    }
    
    bool IsEmergencyShutdownRequested() { return m_emergency_shutdown_requested; }
    string GetEmergencyReason() { return m_emergency_reason; }
    
    string GetStatusString()
    {
        return StringFormat("LC#%d: State=%d | Profit=$%.2f | Risk=$%.2f | Pos=%d", 
                           m_id, m_state, m_current_profit, m_current_risk, GetLifecyclePositionCount());
    }
    
    // NEW: Calculate total profit from both directions
    double CalculateTotalProfit()
    {
        if(m_grid_manager == NULL) return 0.0;
        
        double buy_profit = m_grid_manager.CalculateDirectionTotalProfit(GRID_DIRECTION_BUY);
        double sell_profit = m_grid_manager.CalculateDirectionTotalProfit(GRID_DIRECTION_SELL);
        return buy_profit + sell_profit;
    }
    
    // NEW: Count existing DCA orders to prevent spam
    int CountDCAOrders()
    {
        string job_prefix = StringFormat("J%d_DCA_", m_id); // Match DCA orders for this job
        int count = 0;
        
        for(int i = 0; i < OrdersTotal(); i++)
        {
            ulong ticket = OrderGetTicket(i);
            if(OrderSelect(ticket))
            {
                string comment = OrderGetString(ORDER_COMMENT);
                if(StringFind(comment, job_prefix) >= 0) // This job's DCA orders
                {
                    count++;
                }
            }
        }
        return count;
    }
    
    // NEW: Place DCA rescue orders - ONLY FOR LOSING DIRECTION
    void PlaceDCAOrders()
    {
        if(m_grid_manager == NULL) return;
        
        // üîç CRITICAL: Check if DCA orders already exist to prevent spam
        int existing_dca_orders = CountDCAOrders();
        if(existing_dca_orders > 0)
        {
            Print("‚è∏Ô∏è LIFECYCLE #", m_id, " DCA ORDERS ALREADY EXIST: ", existing_dca_orders, " orders - SKIPPING PLACEMENT");
            return;
        }
        
        // üéØ SMART DCA: Only rescue the losing direction
        double buy_profit = m_grid_manager.CalculateDirectionTotalProfit(GRID_DIRECTION_BUY);
        double sell_profit = m_grid_manager.CalculateDirectionTotalProfit(GRID_DIRECTION_SELL);
        
        Print("üö® LIFECYCLE #", m_id, " DCA ANALYSIS: BUY=$", DoubleToString(buy_profit, 2), " SELL=$", DoubleToString(sell_profit, 2));
        
        bool dca_placed = false;
        
        // If SELL grid is losing more ‚Üí Place BUY STOP to rescue
        if(sell_profit < buy_profit && sell_profit < 0)
        {
            Print("üö® LIFECYCLE #", m_id, " SELL GRID LOSING ‚Üí PLACE BUY STOP RESCUE");
            if(m_grid_manager.ForceDCARescue(GRID_DIRECTION_SELL))
            {
                Print("‚úÖ LIFECYCLE #", m_id, " DCA BUY STOP orders placed to rescue SELL grid");
                dca_placed = true;
            }
        }
        // If BUY grid is losing more ‚Üí Place SELL STOP to rescue  
        else if(buy_profit < sell_profit && buy_profit < 0)
        {
            Print("üö® LIFECYCLE #", m_id, " BUY GRID LOSING ‚Üí PLACE SELL STOP RESCUE");
            if(m_grid_manager.ForceDCARescue(GRID_DIRECTION_BUY))
            {
                Print("‚úÖ LIFECYCLE #", m_id, " DCA SELL STOP orders placed to rescue BUY grid");
                dca_placed = true;
            }
        }
       
        
        if(!dca_placed)
        {
            Print("‚ùå LIFECYCLE #", m_id, " NO DCA RESCUE NEEDED - Both grids profitable");
        }
    }
};

//+------------------------------------------------------------------+
