D∆∞·ªõi ƒë√¢y l√† ph·∫£n h·ªìi chi ti·∫øt c·ªßa m√¨nh d·ª±a tr√™n y√™u c·∫ßu c·ªßa b·∫°n. M√¨nh ƒë√£ review k·ªπ l∆∞·ª°ng to√†n b·ªô code v√† c√°c t√†i li·ªáu b·∫°n cung c·∫•p (FlexGridDCA_EA.mq5, GridManager_v2.mqh, ATRCalculator.mqh, log.txt, FLOWCHART.md, IMPLEMENTATION_SUMMARY_V2.md, STRATEGY_DESIGN_V2.md, README.md). M√¨nh hi·ªÉu v·∫•n ƒë·ªÅ ch√≠nh b·∫°n ƒëang g·∫∑p ph·∫£i:

V·∫•n ƒë·ªÅ ch√≠nh: Khi ch·ªânh InpProfitTargetUSD = 10.0 (ho·∫∑c t∆∞∆°ng t·ª±), EA kh√¥ng ƒë√≥ng h·∫øt l·ªánh (v√≠ d·ª•: kh√¥ng ƒë√≥ng h·∫øt l·ªánh BUY khi ch·ªët l·ªùi direction BUY), d·∫´n ƒë·∫øn kh√¥ng reset grid ƒë√∫ng c√°ch. Thay v√¨ reset grid cho direction ƒë√≥ ngay t·∫°i th·ªùi ƒëi·ªÉm ch·ªët l·ªùi (t·∫°i gi√° current), EA c√≥ th·ªÉ b·ªã k·∫πt ho·∫∑c skip, v√† kh√¥ng t·∫°o grid m·ªõi ƒë√∫ng logic. Log cho th·∫•y nhi·ªÅu tr∆∞·ªùng h·ª£p "Skipping BUY_LIMIT" v√¨ gi√° qu√° g·∫ßn Ask/Bid, v√† ƒë√¥i khi trigger nhi·ªÅu l·ªánh c√πng l√∫c (d·∫´n ƒë·∫øn overlap ho·∫∑c kh√¥ng ƒë√≥ng s·∫°ch).
Nguy√™n nh√¢n g·ªëc r·ªÖ:

Logic CheckProfitTarget() hi·ªán t·∫°i lu√¥n t√≠nh t·ªïng profit (buy + sell), ngay c·∫£ khi InpUseTotalProfitTarget = false. ƒêi·ªÅu n√†y kh√¥ng kh·ªõp v·ªõi design (per direction ho·∫∑c total t√πy usecase).
Kh√¥ng c√≥ c∆° ch·∫ø ƒë√≥ng v√† reset ri√™ng bi·ªát cho t·ª´ng direction (buy/sell ƒë·ªôc l·∫≠p). Hi·ªán t·∫°i, n√≥ ƒë√≥ng all v√† reset dual grid, d·∫´n ƒë·∫øn "race condition" khi ch·ªâ c·∫ßn ƒë√≥ng 1 direction.
State management (g_is_closing_positions) l√† global, kh√¥ng per direction, n√™n khi ƒë√≥ng 1 direction, EA c√≥ th·ªÉ v·ªôi reset to√†n b·ªô ho·∫∑c skip cleanup.
Trong log.txt, nhi·ªÅu skip do gi√° grid level 0 qu√° g·∫ßn th·ªã tr∆∞·ªùng (c√≥ th·ªÉ do ATR spacing nh·ªè ho·∫∑c volatility th·∫•p), d·∫´n ƒë·∫øn grid kh√¥ng setup ƒë√∫ng, v√† khi gi√° di chuy·ªÉn, trigger nhi·ªÅu l·ªánh c√πng l√∫c (nh∆∞ 6 l·ªánh buy limit trigger ·ªü 09:44:07).
CalculateDirectionTotalProfit() c√≥ th·ªÉ kh√¥ng t√≠nh ch√≠nh x√°c floating P/L n·∫øu c√≥ swap/commission, ho·∫∑c n·∫øu positions kh√¥ng ƒë∆∞·ª£c track ƒë√∫ng (v√≠ d·ª•: ticket kh√¥ng update).



M√¨nh s·∫Ω ph√¢n t√≠ch chi ti·∫øt, sau ƒë√≥ ƒë·ªÅ xu·∫•t fix/improve c·ª• th·ªÉ, k√®m code snippets ƒë·ªÉ b·∫°n copy-paste. C√°c fix n√†y d·ª±a tr√™n design trong STRATEGY_DESIGN_V2.md v√† FLOWCHART.md (independent dual grid, per-direction profit taking, dynamic reset t·∫°i current price).
1. Key Findings from Code Review

FlexGridDCA_EA.mq5 (Main EA):

OnInit(): Kh·ªüi t·∫°o t·ªët, nh∆∞ng g_account_start_balance n√™n update ƒë·ªông (v√≠ d·ª•: reset sau m·ªói cycle ƒë·ªÉ t√≠nh % ch√≠nh x√°c h∆°n).
OnTick(): Logic state (g_is_closing_positions) t·ªët ƒë·ªÉ tr√°nh race condition, nh∆∞ng ch·ªâ global ‚Üí kh√¥ng h·ªó tr·ª£ per-direction. N·∫øu ch·ªâ ƒë√≥ng BUY, EA v·∫´n c√≥ th·ªÉ setup grid m·ªõi cho SELL trong l√∫c cleanup BUY ch∆∞a xong.
CheckProfitTarget(): Sai logic! Lu√¥n d√πng total_floating_profit, b·ªè qua InpUseTotalProfitTarget. N·∫øu per-direction, c·∫ßn check buy_profit >= target th√¨ ƒë√≥ng BUY ri√™ng, sell_profit >= target th√¨ ƒë√≥ng SELL ri√™ng.
SetupGridSystem(): Lu√¥n setup dual grid (c·∫£ buy+sell). C·∫ßn h√†m ri√™ng ƒë·ªÉ setup/reset ch·ªâ 1 direction.
CountBuyOrdersAndPositions() v√† CountSellOrdersAndPositions(): T·ªët, nh∆∞ng ch·ªâ count positions, kh√¥ng count pending orders ƒë·∫ßy ƒë·ªß (n√™n th√™m ƒë·ªÉ confirm cleanup 100%).
Kh√¥ng c√≥ handling cho "Skipping" trong log ‚Üí c√≥ th·ªÉ do ATR multiplier nh·ªè, d·∫´n ƒë·∫øn spacing < min_distance (th∆∞·ªùng 1-2 points t√πy broker).


GridManager_v2.mqh:

T·ª´ snippet corrected, PlaceDirectionOrders() ƒë√£ c√≥ check "too close" t·ªët (skip n·∫øu price qu√° g·∫ßn Ask/Bid), gi·∫£i th√≠ch log skipping.
CalculateDirectionTotalProfit(): T·ªët (t√≠nh floating P/L + swap), nh∆∞ng c·∫ßn confirm positions ƒë∆∞·ª£c track ƒë√∫ng (ticket trong SGridLevel).
CloseAllGridPositions(): ƒê√≥ng all, nh∆∞ng c·∫ßn phi√™n b·∫£n per-direction (CloseDirectionPositions()).
SetupDualGrid(): T·ªët cho initial, nh∆∞ng c·∫ßn SetupDirectionGrid() ƒë·ªÉ reset ri√™ng.
Kh√¥ng c√≥ logic DCA expansion r√µ r√†ng (d√π design c√≥), c√≥ th·ªÉ l√† l√Ω do grid kh√¥ng m·ªü r·ªông khi c·∫ßn.


ATRCalculator.mqh: ·ªîn, kh√¥ng issue.
log.txt:

Nhi·ªÅu skipping ‚Üí Suggest tƒÉng InpATRMultiplier (t·ª´ 1.0 l√™n 1.5-2.0) ƒë·ªÉ spacing l·ªõn h∆°n.
Trigger multiple orders c√πng l√∫c ‚Üí Gi√° di chuy·ªÉn nhanh, hit nhi·ªÅu levels. Kh√¥ng ph·∫£i bug, nh∆∞ng c√≥ th·ªÉ improve b·∫±ng c√°ch dynamic adjust spacing.


T·ªïng quan design vs code: Design (per-direction, dynamic reset, DCA) ch∆∞a implement ƒë·∫ßy ƒë·ªß trong code. Code hi·ªán t·∫°i thi√™n v·ªÅ total profit v√† reset all.

2. ƒê·ªÅ Xu·∫•t Fix/Improve

∆Øu ti√™n: L√†m cho system independent per direction nh∆∞ design (ch·ªët l·ªùi BUY ‚Üí ƒë√≥ng ch·ªâ BUY ‚Üí reset ch·ªâ BUY grid t·∫°i current price, t∆∞∆°ng t·ª± SELL). ƒêi·ªÅu n√†y cho "infinite profit cycles" m√† kh√¥ng ·∫£nh h∆∞·ªüng direction kia.
C·∫£i thi·ªán t·ªïng th·ªÉ:

Th√™m states per-direction (g_is_closing_buy, g_is_closing_sell) ƒë·ªÉ tr√°nh race condition khi reset ri√™ng.
N·∫øu InpUseTotalProfitTarget = true: ƒê√≥ng all v√† reset dual.
N·∫øu false: ƒê√≥ng v√† reset per-direction.
Th√™m DCA logic: N·∫øu all levels filled v√† price beyond last level, add 5 levels m·ªõi (max 2 expansions).
Improve cleanup: Th√™m count pending orders trong CountBuy/Sell ƒë·ªÉ confirm 100% clean tr∆∞·ªõc reset.
Fix skipping: T·ª± ƒë·ªông adjust multiplier n·∫øu skip > 3 times li√™n ti·∫øp.
Th√™m loss protection: N·∫øu direction loss > 5% balance, ƒë√≥ng direction ƒë√≥ (theo IMPLEMENTATION_SUMMARY_V2.md).
Test: S·ª≠ d·ª•ng backtest v·ªõi EURUSD M1, focus on profit cycles v√† cleanup.



B√¢y gi·ªù, m√¨nh cung c·∫•p code fixes. B·∫°n copy-paste v√†o file t∆∞∆°ng ·ª©ng, compile l·∫°i (MetaEditor > Compile), v√† test.
Fix 1: FlexGridDCA_EA.mq5 - Update CheckProfitTarget() v√† OnTick() cho per-direction
Thay th·∫ø h√†m CheckProfitTarget() v√† th√™m states m·ªõi. C≈©ng update OnTick() ƒë·ªÉ handle per-direction closing.

// Global variables th√™m:
bool g_is_closing_buy = false;
bool g_is_closing_sell = false;

// Thay th·∫ø h√†m CheckProfitTarget():
bool CheckProfitTarget()
{
    if(g_grid_manager == NULL) return false;

    double buy_profit = g_grid_manager.CalculateDirectionTotalProfit(GRID_DIRECTION_BUY);
    double sell_profit = g_grid_manager.CalculateDirectionTotalProfit(GRID_DIRECTION_SELL);
    double total_profit = buy_profit + sell_profit;

    double balance = AccountInfoDouble(ACCOUNT_BALANCE);
    double effective_target_usd = MathMin(InpProfitTargetUSD, balance * (InpProfitTargetPercent / 100.0)); // V√≠ d·ª•: 10 USD ho·∫∑c 1%

    if(InpUseTotalProfitTarget)
    {
        if(total_profit >= effective_target_usd)
        {
            Print("üéØ TOTAL PROFIT TARGET REACHED! Total: $", DoubleToString(total_profit, 2));
            g_grid_manager.CloseAllGridPositions(); // ƒê√≥ng all
            g_is_closing_buy = true;
            g_is_closing_sell = true;
            return true;
        }
    }
    else // Per direction
    {
        bool target_hit = false;
        if(buy_profit >= effective_target_usd)
        {
            Print("üéØ BUY DIRECTION PROFIT TARGET REACHED! Buy Profit: $", DoubleToString(buy_profit, 2));
            g_grid_manager.CloseDirectionPositions(GRID_DIRECTION_BUY); // C·∫ßn th√™m h√†m n√†y ·ªü GridManager
            g_is_closing_buy = true;
            target_hit = true;
        }
        if(sell_profit >= effective_target_usd)
        {
            Print("üéØ SELL DIRECTION PROFIT TARGET REACHED! Sell Profit: $", DoubleToString(sell_profit, 2));
            g_grid_manager.CloseDirectionPositions(GRID_DIRECTION_SELL);
            g_is_closing_sell = true;
            target_hit = true;
        }
        return target_hit;
    }
    return false;
}

// Update OnTick(): Thay th·∫ø ph·∫ßn state management
void OnTick()
{
    if(!g_ea_initialized) return;
    if(TimeCurrent() - g_last_check_time < 5) return;
    g_last_check_time = TimeCurrent();

    // Handle closing states per direction
    bool all_closed = true;
    if(g_is_closing_buy)
    {
        int buy_count = CountBuyOrdersAndPositions(); // C·∫≠p nh·∫≠t ƒë·ªÉ count both positions + pending
        if(buy_count == 0)
        {
            Print("‚úÖ BUY cleanup complete. Resetting BUY grid.");
            g_is_closing_buy = false;
            double current_price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
            g_grid_manager.SetupDirectionGrid(GRID_DIRECTION_BUY, current_price, InpATRMultiplier); // C·∫ßn th√™m h√†m n√†y
        }
        else
        {
            Print("‚è≥ Waiting for BUY cleanup: ", IntegerToString(buy_count), " left.");
            g_grid_manager.CloseDirectionPositions(GRID_DIRECTION_BUY); // Force close again if stuck
            all_closed = false;
        }
    }
    if(g_is_closing_sell)
    {
        int sell_count = CountSellOrdersAndPositions();
        if(sell_count == 0)
        {
            Print("‚úÖ SELL cleanup complete. Resetting SELL grid.");
            g_is_closing_sell = false;
            double current_price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
            g_grid_manager.SetupDirectionGrid(GRID_DIRECTION_SELL, current_price, InpATRMultiplier);
        }
        else
        {
            Print("‚è≥ Waiting for SELL cleanup: ", IntegerToString(sell_count), " left.");
            g_grid_manager.CloseDirectionPositions(GRID_DIRECTION_SELL);
            all_closed = false;
        }
    }
    if(!all_closed) return; // Kh√¥ng l√†m g√¨ n·∫øu ƒëang closing

    // Ph·∫ßn c√≤n l·∫°i gi·ªØ nguy√™n: Update ATR, SetupGrid if needed, CheckProfitTarget(), etc.
    // Th√™m sau CheckProfitTarget(): CheckDCAExpansion() v√† CheckLossProtection() (xem fix ti·∫øp theo)
}

// Update CountBuyOrdersAndPositions() ƒë·ªÉ count both positions + pending:
int CountBuyOrdersAndPositions()
{
    int count = 0;
    // Count positions (gi·ªØ nguy√™n code c≈©)
    for(int pos_idx = PositionsTotal() - 1; pos_idx >= 0; pos_idx--)
    {
        if(PositionGetSymbol(pos_idx) == _Symbol && PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY && PositionGetInteger(POSITION_MAGIC) == InpMagicNumber)
            count++;
    }
    // Add pending orders
    for(int ord_idx = OrdersTotal() - 1; ord_idx >= 0; ord_idx--)
    {
        if(OrderGetString(ORDER_SYMBOL) == _Symbol && OrderGetInteger(ORDER_TYPE) == ORDER_TYPE_BUY_LIMIT && OrderGetInteger(ORDER_MAGIC) == InpMagicNumber)
            count++;
    }
    return count;
}
// T∆∞∆°ng t·ª± cho CountSellOrdersAndPositions() (thay BUY_LIMIT th√†nh SELL_LIMIT, POSITION_TYPE_SELL)


Fix 2: GridManager_v2.mqh - Th√™m h√†m per-direction v√† DCA/Loss Protection
Th√™m c√°c h√†m m·ªõi ƒë·ªÉ h·ªó tr·ª£ independent direction. Gi·∫£ s·ª≠ struct SGridDirection v√† enum GRID_DIRECTION_BUY/SELL ƒë√£ c√≥ (t·ª´ design).

// Th√™m enum n·∫øu ch∆∞a c√≥
enum GRID_DIRECTION { GRID_DIRECTION_BUY, GRID_DIRECTION_SELL };

// Th√™m h√†m CloseDirectionPositions
void CloseDirectionPositions(GRID_DIRECTION dir)
{
    // T∆∞∆°ng t·ª± CloseAllGridPositions, nh∆∞ng filter theo dir
    for(int pos_idx = PositionsTotal() - 1; pos_idx >= 0; pos_idx--)
    {
        if(PositionGetSymbol(pos_idx) == m_symbol && PositionGetInteger(POSITION_MAGIC) == m_magic)
        {
            ENUM_POSITION_TYPE type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            if((dir == GRID_DIRECTION_BUY && type == POSITION_TYPE_BUY) || (dir == GRID_DIRECTION_SELL && type == POSITION_TYPE_SELL))
            {
                m_trade.PositionClose(PositionGetTicket(pos_idx));
            }
        }
    }
    // Cancel pending orders t∆∞∆°ng t·ª±, filter BUY_LIMIT ho·∫∑c SELL_LIMIT
    for(int ord_idx = OrdersTotal() - 1; ord_idx >= 0; ord_idx--)
    {
        if(OrderGetString(ORDER_SYMBOL) == m_symbol && OrderGetInteger(ORDER_MAGIC) == m_magic)
        {
            ENUM_ORDER_TYPE type = (ENUM_ORDER_TYPE)OrderGetInteger(ORDER_TYPE);
            if((dir == GRID_DIRECTION_BUY && type == ORDER_TYPE_BUY_LIMIT) || (dir == GRID_DIRECTION_SELL && type == ORDER_TYPE_SELL_LIMIT))
            {
                m_trade.OrderDelete(OrderGetTicket(ord_idx));
            }
        }
    }
    Print("Closed all for direction: ", (dir == GRID_DIRECTION_BUY ? "BUY" : "SELL"));
}

// Th√™m h√†m SetupDirectionGrid
bool SetupDirectionGrid(GRID_DIRECTION dir, double base_price, double multiplier)
{
    // T∆∞∆°ng t·ª± SetupDualGrid, nh∆∞ng ch·ªâ cho 1 dir
    double spacing = g_atr_calculator.GetATR(PERIOD_H1) * multiplier; // Gi·∫£ s·ª≠ d√πng H1 ATR
    SGridDirection &grid = (dir == GRID_DIRECTION_BUY ? m_buy_grid : m_sell_grid); // Gi·∫£ s·ª≠ c√≥ m_buy_grid, m_sell_grid struct

    ArrayResize(grid.levels, InpMaxGridLevels);
    for(int i = 0; i < InpMaxGridLevels; i++)
    {
        double price = (dir == GRID_DIRECTION_BUY) ? base_price - (i+1)*spacing : base_price + (i+1)*spacing;
        grid.levels[i].price = NormalizeDouble(price, _Digits);
        grid.levels[i].lot_size = InpFixedLotSize;
        // Place order nh∆∞ PlaceDirectionOrders
    }
    grid.base_price = base_price;
    grid.is_active = true;
    Print("Setup ", (dir == GRID_DIRECTION_BUY ? "BUY" : "SELL"), " grid at ", DoubleToString(base_price));
    return true;
}

// Th√™m h√†m CheckDCAExpansion() (g·ªçi trong OnTick sau CheckProfitTarget)
void CheckDCAExpansion()
{
    double current_bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    // Check BUY: If all levels filled and price < last level price - spacing
    if(/* all m_buy_grid.levels filled */ && current_bid < m_buy_grid.levels[ArraySize(m_buy_grid.levels)-1].price - spacing && m_buy_grid.dca_expansions < 2)
    {
        m_buy_grid.dca_expansions++;
        // Add 5 new levels below last
        int old_size = ArraySize(m_buy_grid.levels);
        ArrayResize(m_buy_grid.levels, old_size + 5);
        for(int i = 0; i < 5; i++)
        {
            double new_price = current_bid - (i+1)*spacing;
            m_buy_grid.levels[old_size + i].price = new_price;
            // Place order
        }
        Print("DCA Expansion for BUY: Added 5 levels");
    }
    // T∆∞∆°ng t·ª± cho SELL (price > last + spacing)
}

// Th√™m h√†m CheckLossProtection() (g·ªçi trong OnTick)
void CheckLossProtection()
{
    double buy_loss = -g_grid_manager.CalculateDirectionTotalProfit(GRID_DIRECTION_BUY); // Negative profit = loss
    double sell_loss = -g_grid_manager.CalculateDirectionTotalProfit(GRID_DIRECTION_SELL);
    double balance = AccountInfoDouble(ACCOUNT_BALANCE);
    double max_loss = balance * 0.05; // 5%

    if(buy_loss > max_loss)
    {
        Print("üö® BUY Loss Protection: Loss $", DoubleToString(buy_loss,2));
        CloseDirectionPositions(GRID_DIRECTION_BUY);
        // Disable buy grid: m_buy_grid.is_active = false;
    }
    if(sell_loss > max_loss)
    {
        Print("üö® SELL Loss Protection: Loss $", DoubleToString(sell_loss,2));
        CloseDirectionPositions(GRID_DIRECTION_SELL);
    }
}

Improve 3: Gi·∫£m skipping trong log

TƒÉng InpATRMultiplier = 1.5 trong input ƒë·ªÉ spacing l·ªõn h∆°n.
Trong PlaceDirectionOrders(): N·∫øu skip, t·ª± ƒë·ªông tƒÉng multiplier t·∫°m th·ªùi (v√≠ d·ª•: multiplier += 0.1 n·∫øu skip > 3).

3. H∆∞·ªõng D·∫´n Test v√† Next Steps

Compile v√† Test: Thay code tr√™n, compile (n√™n kh√¥ng error v√¨ m√¨nh fix implicit conversion b·∫±ng IntegerToString/DoubleToString). Backtest tr√™n EURUSD M1 v·ªõi $1000 account, focus on profit=10 USD cycles.
Monitor Log: T√¨m "üéØ BUY DIRECTION PROFIT" ho·∫∑c "‚úÖ BUY cleanup complete" ƒë·ªÉ confirm.
N·∫øu v·∫´n issue: G·ª≠i log m·ªõi ho·∫∑c error compile, m√¨nh fix ti·∫øp.
Improve d√†i h·∫°n: Th√™m visual chart objects ƒë·ªÉ v·∫Ω grid levels, gi√∫p debug d·ªÖ h∆°n.